<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Jinge's Blog on Github"><title>LeetCode #146 LRU Cache (Difficulty: Hard) | Jinge's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/leetcode/">leetcode</a></div><div class="post-time">2016-03-15</div></div></div><div class="container post-header"><h1>LeetCode #146 LRU Cache (Difficulty: Hard)</h1></div><div class="container post-content"><p>问题 : &gt;Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>. <code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. <code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<a id="more"></a>
<p><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="external">原题链接</a></p>
<p>这个问题是要维护一个缓存，缓存中数据移除数据的依据是这个数据 Least Recently Used ， 也就是使用时间距现在最远（最早使用）。一开始理解错误，以为是最少使用，代码就写错了。经过一点小修改符合题意。代码如下。</p>
<p>C++ :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">class LRUCache &#123;</div><div class="line">    struct Pair &#123;</div><div class="line">        int key;</div><div class="line">        int val;</div><div class="line">    &#125;;</div><div class="line">public:</div><div class="line">    int cap;</div><div class="line">    int* count;</div><div class="line">    Pair* pairs;</div><div class="line">    LRUCache(int capacity) &#123;</div><div class="line">        cap = capacity;</div><div class="line">        pairs = new Pair[cap];</div><div class="line">        count = new int[cap];</div><div class="line">        for (int i = 0; i &lt; cap; i++) &#123;</div><div class="line">            count[i] = -1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int get(int key) &#123;</div><div class="line">        for (int i = 0; i &lt; cap; i++) &#123;</div><div class="line">            if (count[i] != -1 &amp;&amp; pairs[i].key == key) &#123;</div><div class="line">                updateCount(i);</div><div class="line">                return pairs[i].val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void set(int key, int value) &#123;</div><div class="line">        int maxIdx = 0;</div><div class="line">        int maxCount = count[0];</div><div class="line">        if(maxCount == -1) &#123;</div><div class="line">                pairs[0].key = key;</div><div class="line">                pairs[0].val = value;</div><div class="line">            updateCount(0);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (pairs[0].key == key) &#123;</div><div class="line">            pairs[0].val = value;</div><div class="line">            updateCount(0);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for (int i = 1; i &lt; cap; i++) &#123;</div><div class="line">            if(maxCount == -1) &#123;</div><div class="line">                pairs[i].key = key;</div><div class="line">                pairs[i].val = value;</div><div class="line">                updateCount(i);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            if (pairs[i].key == key) &#123;</div><div class="line">                pairs[i].val = value;</div><div class="line">                updateCount(i);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            if (maxCount &lt; count[i]) &#123;</div><div class="line">                maxCount = count[i];</div><div class="line">                maxIdx = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        pairs[maxIdx].key = key;</div><div class="line">        pairs[maxIdx].val = value;</div><div class="line">        updateCount(maxIdx);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void updateCount(int idx) &#123;</div><div class="line">        for (int i = 0; i &lt; cap; i++) &#123;</div><div class="line">                if (count[i] != -1) count[i] ++;</div><div class="line">        &#125;</div><div class="line">        count[idx] = 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这部分的代码的意思是，使用 pairs 数组表示存储在缓存中的键值对，使用 count 数组表示 pairs 数组中这些对应位置的键值对的使用情况。如果 pairs 中 idx 位置上的键值对使用了，那么久把 count 中 idx 位置上的值赋为0，其他位置上的值自增1。当要插入的时候就插入到 count 最大值的位置上。这个代码很烂。</p>
<p>下面是在<a href="https://leetcode.com/discuss/91752/lovely-30-line-c-80ms-solution" target="_blank" rel="external">讨论区</a>找到的代码。使用了两个数据结构，一个 list 用于存储键值对，一个 map 用于保存键在 list 中对应的位置。从代码中可以看到， list 中各键值对的顺序是最近访问的键值对在 list 头部，而 map 没有固定的顺序。</p>
<p>C++ :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class LRUCache&#123;</div><div class="line">    const int cap;</div><div class="line">    std::unordered_map&lt;int, std::list&lt;std::pair&lt;int, int&gt; &gt;::iterator&gt; map;</div><div class="line">    std::list&lt;std::pair&lt;int, int&gt;&gt; lst;</div><div class="line">public:</div><div class="line">    LRUCache(int capacity):cap(capacity) &#123;&#125;</div><div class="line">    </div><div class="line">    int get(int key) &#123;</div><div class="line">        auto it = map.find(key);</div><div class="line">        if(it == map.end()) return -1;</div><div class="line">        </div><div class="line">        lst.push_front(*it-&gt;second);</div><div class="line">        lst.erase(it-&gt;second);</div><div class="line">        it-&gt;second = lst.begin();</div><div class="line">        return it-&gt;second-&gt;second;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void set(int key, int value) &#123;</div><div class="line">        auto it = map.find(key);</div><div class="line">        if(it == map.end())&#123;</div><div class="line">            while (map.size() &gt;= cap) &#123;</div><div class="line">                map.erase(lst.crbegin()-&gt;first);</div><div class="line">                lst.pop_back();</div><div class="line">            &#125;</div><div class="line">        &#125;else&#123;</div><div class="line">            lst.erase(it-&gt;second);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        lst.push_front(&#123;key, value&#125;);</div><div class="line">        map[key] = lst.begin();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
  inlineMath: [ ['$','$'], ["\\(","\\)"] ],
  processEscapes: true
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
   var all = MathJax.Hub.getAllJax(), i;
   for(i=0; i < all.length; i += 1) {
       all[i].SourceElement().parentNode.className += ' has-jax';
   }
});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></html>